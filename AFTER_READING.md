# From start to finish

I started reading about two years ago in the summer, and finished reading the book "Concepts, Techniques, and Models of Computer Programming," which I was constantly reading. Well, even though I read it, I didn't do the exercises at the end of the chapter from the middle, so I think I thought about all the important things. I read it about 2 to 4 times depending on the chapter.

This book was just read when I started to study computer science, so by summarizing the process, I thought about what I had learned and what else I was missing. I want to sort things out.

## Summary of each chapter

A summary of each chapter I wrote to organize what I read.

- [Introduction: Learning programming](http://d.hatena.ne.jp/Altech/20110101/1293896398) - 2011-01-01
- [CTMCP Chapter 1: Introduction to Programming Concepts](http://d.hatena.ne.jp/Altech/20110104/1294156496) - 2011-01-04
- [CTMCP Chapter 2: Declarative Computation Model](http://d.hatena.ne.jp/Altech/20110720/1311091857) - 2011-07-20
- [CTMCP Chapter 3: Declarative Programming Techniques](http://d.hatena.ne.jp/Altech/20110804/1312404118) - 2011-08-04
  - [What is declarative?](http://d.hatena.ne.jp/Altech/20110801/1312131972)
- [CTMCP Chapter 4: Parallelism of the Declaration](http://d.hatena.ne.jp/Altech/20120318/1332006007) - 2012-03-18
  - [A little bit about nondeterminism](http://d.hatena.ne.jp/Altech/20120318/1332056930)
- [CTMCP Chapter 5: Message Transmission Concurrency](http://d.hatena.ne.jp/Altech/20120322/1332364501) - 2012-03-22
- [CTMCP Chapter 6: Express State](http://d.hatena.ne.jp/Altech/20120506/1336258094) - 2012-03-22
- [CTMCP Chapter 7: Object Oriented Programming](http://d.hatena.ne.jp/Altech/20120515/1337090224) - 2012-05-15
- [CTMCP Chapter 8: State Common Parallelism](http://d.hatena.ne.jp/Altech/20121021/1350830918) - 2012-10-21
- [CTMCP Chapter 9: Relational Programming](http://d.hatena.ne.jp/Altech/20121021/1350832754) - 2012-10-21
- [CTMCP Chapter 11: Distributed Programming](http://d.hatena.ne.jp/Altech/20121021/1350835101) -2012-10-21
- [CTMCP Chapter 12: Constraint Programming](http://d.hatena.ne.jp/Altech/20121023/1350987658) - 2012-10-23


## Motivation and motivation

When I was thinking that "I entered the department of information engineering and want to read a proper computer science book" during the summer vacation of the first year of university, this is from the draftcode who was resident in the club room for some reason at the OB of the circle. I had you introduce a book. However, at this time, I had almost no programming experience or basic knowledge about computer science, so I had to understand the prerequisites as well, and the number of pages was not so good.

Even in such a situation, I forcibly read that there was a premonition that if I learned programming on the "specification" of a specific programming language, I would think with that preconception (it is difficult to remove such preconception). It was because By the way, I think this is half right and half wrong at the moment. Even with such a way of entering, if you touch many different languages, the essential differences will gradually be sorted out. In contrast, this book is a book that deals with such essence from the beginning and teaches programming based on it, and I wanted to do so, and I wanted to have a more fundamental understanding without distortion.

## What kind of book?

Since this book is written with deep backing, how much you can get is up to you to read. That is programming as the title says. If programming is divided into the following three,

1. Concepts and techniques
2. Algorithms and data structures
3. Program design and software engineering

Of these, 1. will be treated thoroughly, and 2. and 3. will be treated as an introduction. And 1. and 3. have a strong interrelationship (as I said in the introduction). For example, the concept of "synthesizable" or "synthesizable component" and the technique (e.g. memoization) for realizing a composable component with good performance are the concepts and techniques necessary for designing loosely coupled programs. In my impression, in general, there are many programming introductory books that explain what functions programming languages ​​have and what techniques are possible, but at the same time, what to do from a larger standpoint (that is, perspective 3). I don't think that is often explained. On the other hand, this book teaches 1. and 3. in parallel, so I felt that I could build a relatively solid foundation for 3. too. For example, I read a book called "Myth of the Moon", a classic of software engineering (even if I didn't have much development experience), and I was completely satisfied. On the other hand, although the basics of algorithms and data structures are suppressed, I feel that they are still insufficient. What should I do.

## from now on

It is generally understood by anyone who tries it, but engineering for information such as computing, information system, information technology or engineering using a computer does not consist only of programming separately, In a sense, this book is only part. First of all, programming is not possible without hardware, and it is meaningless to program if there is knowledge about the programming target and problem setting cannot be done accurately. The rest is the platform (OS, browser, language processing system), environment (libraries, community, people), solution method, and natural language. Maybe there are some things we can't see yet.

I don't know what I want to do in the first place, but I think computing is a broad and interesting way to make everyday life easier (or even more fun). I want to be able to do it myself. It turned out to be a very abstract story, so when I go back to the concrete story, I tend to be in a layer with a high degree of abstraction from Oz to Ruby, and I understand exactly the low layer part. I feel that there isn't any, so I'm wondering if I should study OS next time.

